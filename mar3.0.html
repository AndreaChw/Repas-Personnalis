<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Bienvenue au restaurant Le Fossile, qu’allez-vous manger ce soir ?</title>
    <meta charset="utf-8" />
    <meta name="author" content="Chahwan, Ndaya Nsabua, Delpont" />
    <meta name="date" content="2025-01-09" />
    <script src="mar3.0_files/header-attrs-2.28/header-attrs.js"></script>
    <link href="mar3.0_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="mar3.0_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Bienvenue au restaurant <em>Le Fossile</em>, qu’allez-vous manger ce soir ?
]
.author[
### Chahwan, Ndaya Nsabua, Delpont
]
.date[
### 2025-01-09
]

---


# Introduction

- Objectif du projet :
  - Détermier le type de personnalité de l'utilisateur
  - Proposer un menu personnalisé

- Méthodologie :
  - Recherche des données &amp; Création des bases de données
  - Test de personnalité
  - Sélection

---

# Construction de la base de données
## Méthode considérées &amp; problèmes envisagés
Utiliser une IA (e.g. Gemini, ChatGPT) pour créer une base de donnée à partir du fichier d'un menu (PDF). La réponse serait demandée sous format CSV ou XLS.
- Méthodes :
  - API (e.g. OpenAI) --&gt; payante
  - Integration d'une NPL open source (comme Stanford NLP Group) dans R
    - Problème : Mauvaise version de Java
  - Création d'un bot qui fait une requette à une IA
    - L'IA propose des réponses non standards 
    - Nécessiterait un bot plus avancé pour identifier la bonne information dans le message

---

# Construction de la base de données
## Méthode adoptée
Créer notre propre base de donnée en se basant sur le menu du restaurant strasbourgois **Le Fossile**.

---

# Importation des Données

- Les fichiers utilisés :
  - Descriptions des plats : caractéristiques des desserts, viandes, boissons, etc.
  - Menus triés par type (entrées, viandes, desserts, boissons).

- Formats utilisés : Excel.

- Exemple de structure de données :

![Base de données des desserts triées par personnalité](C:/Users/PC/Documents/Cours/Master/S1/Analyse de données/projet/desserts.jpg)

---

![Base de données des plats avec leurs descriptions](C:/Users/PC/Documents/Cours/Master/S1/Analyse de données/projet/description.jpg)

---

## Test de personnalité.

Nous avons déterminé 6 types de personnalité :

 - Aventurier
 
 - Traditionnaliste
 
 - Gourmet
 
 - Minimaliste
 
 - Fêtard
 
 - Épicurien
 
---

## Déroulé du test

Le programme propose 7 affirmations, par exemple : 

 - *1. Vous aimez explorer des endroits inconnus, même sans plan précis.*
 
 - *2. Vous trouvez du confort dans les routines bien établies et les traditions.*

Exemple de ce à quoi le code ressemble pour l'utilisateur :

```
&gt; # Poser les questions et calculer les scores
&gt; for (i in seq_along(questions)) {
+   response &lt;- ask_question(questions[i])
+   for (personality in  .... [TRUNCATED] 
1. Vous aimez explorer des endroits inconnus, même sans plan précis. 
Répondez par : 1 = D'accord, 2 = Plutôt d'accord, 3 = Indifférent,
4 = Plutôt en désaccord, 5 = En désaccord

Votre réponse : 1
```
---

## Le Système de poids

Chaque personnalité est associée à un vecteur de poids :
![Tableau-des-poids](C:/Users/PC/Documents/Cours/Master/S1/Analyse de données/projet/poids.jpg)

Erreur que nous avons fait :

 - Somme des poids des personnalités inégales

---

## Calcul des scores
On fait donc la somme pondérée des réponses pour chaque personnalité.
Puis tri des personnalités en fonction de leur score :

 - Personnalité avec le plus haut score : ```main_personnality```
 
 - Personnalité avec le second plus haut score : ```secondary_personnality```

```
Votre personnalité principale est : Fetard - Vous aimez profiter des 
moments festifs entre amis, sortir, et vivre pleinement la vie sociale. 

On dirait que vous avez un petit côté caché qui se manifeste en vous ! Votre 
personnalité secondaire est : Aventurier - Vous êtes curieux(se) et aimez 
explorer de nouvelles expériences et lieux, souvent sans plan précis. Vous 
vivez pour l’excitation et la découverte.

```
---

## Sélection des plats en fonction de la personnalité

Dans cette partie, le code propose des entrées, des plats et desserts en fonction de la personnalité principale ```[main_personality]``` d'un utilisateur. Les recommandations sont enrichies par des descriptions.

### 1.Recommandation des plats 

#### *Extraction des données*

On vérifie si ```[main_personality]``` correspond à une colonne du dataframe ```(Entrees_triees)```, ```(Desserts_triees)``` ou ```(Viandes_triees)```. Si oui, les plats associés à cette personnalité sont extraites et les valeurs manquantes sont éliminées avec ```na.omit()```.Et les plats sont affichées à l'utilisateur

---

#### *Explications* 
Si l'utilisateur le souhaite (réponse ```"Oui"```), des descriptions des plats sont recherchées dans le dataframe ```Description_plats``` est affichées

Exemple code avec les entrées :
```
selected_entrees &lt;-Entrees_triees[[main_personality]]
selected_entrees &lt;- na.omit(selected_entrees)
entrees_descriptions &lt;- Description_plats[Description_plats$nom_plat %in% selected_entrees, ]
```

---

### 2.Recommandation des boissons

#### *Filtrage par alcool* 

L'utilisateur indique s'il souhaite consommer de l'alcool. Selon sa réponse , les boissons correspondantes sont filtrées dans le dataframe ```Boissons_triees``` (en fonction de la colonne Alcool).

#### *Personnalité secondaire*

Les boissons sont filtrées en fonction de ```secondary_personality```, contrairement aux plats qui l'étaient en fonction de ```main_personality```
Si demandé, des descriptions des boissons sont affichées.

Code boissons :
```
response &lt;- readline(prompt = "Souhaitez-vous boire de l'alcool ? (Oui/Non) : ")
 selected_boissons &lt;- Boissons_triees[Boissons_triees$Alcool == ifelse(response == "Oui", 1, 0), ]
 selected_boissons &lt;- selected_boissons[[secondary_personality]]
 selected_boissons &lt;- na.omit(selected_boissons)
```

---

### 3.Gestion des erreurs 

Si la personnalité (secondary_personality ou main_personality)n'est pas trouvée dans les colonnes des dataframes, un message d'erreur est affiché pour informer l'utilisateur

Si aucune description n'est disponible, un message est affiché pour informer l'utilisateur

### 4.Fonctionnalités interactives

Le programme utilise  readline()  pour obtenir des réponses de l'utilisateur de manière interactive :

Si l'utilisateur souhaite des explications sur les plats.

Si l'utilisateur souhaite consommer de l'alcool pour les boissons.

Code :
```
response &lt;- readline(prompt = "Souhaitez-vous des explications sur ces plats ? (Oui/Non) : ")
  
  if (tolower(response) == "oui") {
    # Rechercher les descriptions
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
